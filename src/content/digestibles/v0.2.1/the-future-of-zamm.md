---
title: 'The future of ZAMM'
blogPost: 'v021'
pubDate: 'December 31, 2024'
---

This is perhaps the first bug in ZAMM that was unambiguously caught by automated testing, that I would not have discovered otherwise for quite a while. I never use that part of the app after initial setup, and even then it would've been unlikely for me to try to completely clear the file path first instead of simply editing the existing one or pasting a new one in.

All in all, I don't know if that actually says anything positive about my obsession with testing. This has been the only unambiguously clear-cut win for testing over the last year of development on ZAMM, and it turned out to be a rather inconsequential win. There was also at some point a UI screenshot test that failed because I changed the CSS in one component and ended up inadvertently affecting the layout for some another component, but that one would've been caught sooner or later anyways, and the vast majority of screenshot test failures are expected changes to the screenshots in the CI environment. (Font rendering, among other minor things, is slightly different in every environment I run the tests in, so I can't just update the screenshots directly during development.) It would've been more practical to simply have never known about bugs like these, and instead redirect the time spent writing and debugging their respective tests towards having ZAMM actually do the things I want it to do. I don't mean to make this an extreme dichotomy where the other option is to get rid of tests entirely; that would clearly be impractical for long-term project development. I mean testing only the important things so that the project can move forward faster to actually meet its stated goals.

But that requires a level of comfort with uncertainty that I currently do not have, and this is a personal project self-funded entirely by personal morale. In lieu of a juicy paycheck that keeps me coming to the office no matter how much of a piece of shit the product is, I currently rely on a sense of pleasure at the state of the app and the codebase, and the tests catching an error as inconsequential as this is a great confidence booster for the state of more major pieces of functionality. This is akin to how non-profits will dedicate resources to securing future funding instead of focusing purely on their mission statement. After all, the non-profit scaling back or even shutting down due to lack of funding would be pretty bad for its mission statement. (The less charitable take is that humans in positions of power are primed to want more power, and given [Pournelle's Iron Law of Bureaucracy](https://www.jerrypournelle.com/reports/jerryp/iron.html), the charity is going to prioritize its own growth over the execution of its mission statement. One could argue the UN has fallen for this as well, as I've now met two UN employees who are quite cynical about management's obsession with their own personal political power games.)

This sense of pleasure is especially clear to me when looking at animations, which are the main aspect of the app that I can't really test in an automated fashion and which I therefore lack the same sense of certainty and control over. For this migration, I had to manually check all the transition effects I could think of checking -- and boy were many of them broken! In fact, because I was also taking the opportunity to simplify my mock Storybook layouts, these animations would occasionally be re-broken, and I wouldn't even know until I manually tested them again. I hate this feeling of taking one step forward here and one step backwards in another random place, because as I mentioned with debugging earlier, a sense of monotonically increasing progress is a great boost to my personal morale. Fortunately the number of animations to test are rather limited because I started focusing on features and functionality after v0.1.0, and this sort of uncertainty is also limited to this particular part of the app.

And so, I've come to accept that at the current pace, with the current way I'm doing things due to my current coding personality, it's going to take years before ZAMM is functional in the way I want it to be. Which means it's going to be years before ZAMM matters, which means that ZAMM is basically *never* going to matter because I can't imagine a field as dynamic as this one not eventually churning out the product I want to use.

I'm of two opinions about this. One is that the intrinsic motivation for working on ZAMM is always going to be there for so long as it or a proper substitute does not exist. Suppose I were to accept that I should just give up and leave the implementation of this idea up to somebody else. But let's say it's going to be three years before somebody else executes the vision I have in the way that I like. What would I want to do with my life in the intervening three years while I wait for that other thing to come online? Well, there's still a lot of projects I would like to work on, and so I would like to at least have a poor man's version of that other thing available for use on these other projects. Have something unprofessional, something that just barely works, to tide over the time before a proper solution arrives on the scene. But what would this new project be, but simply ZAMM under a different name?

I should therefore go for broke in a completely new rewrite. To take a space analogy, if you launch a probe into space at low velocity, it's going to soar into the sky and possibly even into space before Earth's continual gravituational pull slows its ascent to a standstill and then tugs it all the way back down onto the ground. If you launch a space probe fast enough and at the right angle, it can perhaps move fast enough to avoid crashing back down, but still be too slow to completely escape the Earth's clutches either -- which is also known as "orbiting" the Earth. Sometimes, this is exactly what you want, to just send a satellite into space that continually hangs around in the Earth's vicinity. But if you launch a space probe *really* fast, faster than even its "[escape velocity](https://en.wikipedia.org/wiki/Escape_velocity)," it can leave the gravitational influence of the Earth forever.

So then, I'm thinking that it may be worth trying once again to start this project from scratch, fly as fast as possible for a month or so with the latest and greatest AI coding tools, ignore tests or code quality or any other forms of long-term project sustainability as much as practical, and see whether I manage to make it to orbit before any of that matters, before the gravitational pull of geometrically increasing complexity slows project progress down to a crawl. Perhaps my personal distaste for a low-quality, low-confidence codebase can be offset by the continual dopamine hits I get from making new features work. If the launch sputters and I fail to achieve escape velocity in time, I can always return to the current project state with its plodding progress. I want to give this a shot because this new friend I made in Siem Reap introduced me to [bolt.new](https://bolt.new/), and showed me the impressive speed with which he can now automate the building of websites. My approaches to ZAMM in particular and productivity in general this year have not been working great, so it's perhaps time to try out some new approaches for this new year. (As 2024 draws to a close, I find myself mentally exhausted and unwilling to work, hence the extreme delay in getting this blog post out. But I am nowhere at all as exhausted as I was touring New Zealand at the end of 2023, so I have definitely made some major improvements to the sustainability of my work ethic this year.)

The other opinion I have is that I want to keep exploring that feeling of this project not mattering. In [the last update](/blog/v0.2.0/), I mentioned how having a second project going meant that I could take this one less seriously. That other project has since stalled because my partner hasn't worked much on it, and I don't want to be the only one working on it. I don't blame them at all because giving up on a project is something I'm all too familiar with. But I think having even a moment where it truly felt like ZAMM didn't need to matter allowed me to recognize and explore this feeling more, and in doing so I found that the project not mattering allows me to be more fully present in the moment, rather than always needing to subjugate the present moment in service of a future goal, with all forms of relaxation nothing more than a temporary diversion enabling the more efficient subjugation of a future present moment.

I had of course started out fully intending for ZAMM to be practically useful to *me*, at the very least. But as Coach Bennett from Nike Run Club says, you don't run towards a goal, you run with it. Goals are there to help you, and you write your goals in pencil so that as you change, your goals can change with you. Or as [CJ the X says](https://youtu.be/GZg_36utl2w), working towards a goal is part of the experience of life even if achieving goals isn't the end all be all of life. Given the way this project and my life has played out over the past year, I think it's best for me to proceed under the attitude that whatever work I do on ZAMM is going to negligibly impact my future career prospects. I have been trying out the dream of automating coding in various ways (especially with natural language) throughout my 20's, falling for the classic fallacy that because it's so straightforward for me, it must also therefore be straightforward to program into the computer. The entire field of [natural language processing](https://en.wikipedia.org/wiki/Natural_language_processing) (NLP) drives home that point very severely: human language is something that humans of all intelligence levels can trivially grasp, and yet for the longest time computers had trouble understanding even basic [Winograd schemas](https://en.wikipedia.org/wiki/Winograd_schema_challenge). Having even *gone* to school specifically to get a master's in NLP, how did I ever think it would've been possible for me as a solo developer with no machine learning training to tackle such a hard problem? I am at a loss to explain my former levels of unmitigated "delulu" other than chalking it up to the [hubris of youth](https://www.reddit.com/r/RedditInsider/comments/21v7ch/you_need_to_know_about_udarqwolff/).

So if present-me were to say something to the past-me of April 2016, when I was first smitten by this dream at 20 years old, it would be this: "Give up now. The time is not yet ready. Wait until these things called 'LLM's' start making it into the mainstream around 2020, or maybe even wait until this thing called 'chain-of-thought prompting' gets invented in 2022. Until then, you might as well just fuck around and do whatever else you want, because literally none of it is going to matter until 2022. Oh and BUY BITCOIN!" I think future me may well give present me that advice too, but if they do then this time around I am much better equipped to actually take the non-Bitcoin advice than early 20's me would've been. At the very least, I'll work on ZAMM knowing knowing full well that it's not going to matter.

You could ask, what's the point in working on a project that doesn't matter? But you might as well ask, what's the point in living a life that doesn't matter (in the grand scheme of things)? "It's kind of enjoyable" is all the justification you really need. One thing this refactoring experience has made clear to me is that this project gives me a sense of control over my computing experience like nothing else does. Here is a tiny plot of land that I've carved out for myself. It is an economically unproductive plot of land, but it is one I have full control over, at least insofar as one has full control over anything in the digital world. I control when the upgrades happen, when the settings change, how the UI shifts or doesn't shift. Nobody is running [A/B tests](https://en.wikipedia.org/wiki/A/B_testing) on me and remotely flipping a switch that changes how my software works, as I've done to millions of users in the past myself. If I don't like something, I know where and how to fix it, and I can do so on my own schedule instead of waiting for an external entity to finally prioritize my issue. To me, this is digital empowerment. Perhaps it reflects the degree of control I yearn for over my own life.

I think this is what Richard Stallman was getting at with all his talk about [free software](https://www.gnu.org/philosophy/free-sw.html) -- "free" as in speech, not as in beer. "Free" includes the freedom to change and improve the software, but like with other freedoms, an economically constrained individual doesn't feel very "free" to do the thing the freedom is about. I feel economically constrained by the time and energy I have to spend on understanding other people's software in order to modify it, so I generally don't do so without strong motivation. With ZAMM, the cost is pre-paid because I made it myself, so I get to have a taste of that software freedom even if the freedom doesn't lead to anything practical. (I should mention that even if a freedom is only economically accessible to a small subset of society, it's still important that the freedom exists for anyone fortunate enough to find themselves in a spot to exercise it.)

And of course, if I want this project to matter, I can also take the perspective that it has already mattered in all sorts of indirect ways. Whatever I do next will be informed by my experience working on ZAMM, both in terms of the technical expertise and what I've learned about myself in the process. When it comes to technical expertise, I'm glad that I've worked on this project for long enough to have the opportunity to do these sort of major migrations; at my previous jobs, I've only ever done complete rewrites or seamless migrations. I can now further appreciate both the challenges of this sort of migration, and the ways in which I believe LLMs could really help with such large-scale changes to the codebase. Even a modicum of understanding goes a long way in doing simple refactors that automated migration scripts cannot otherwise handle.

And when it comes to knowing myself, I think I have become much better at recognizing not just the extent of my limitations, but also the range of my present capabilities. It feels excruciatingly frustrating at times to not only have such extreme limitations on my personal productivity, but also to not feel as if there's a clear path to overcoming those limitations. I've felt this sort of frustration at my leg too during my race training, where first heel pain and then later knee pain would pop up. "Why can't you just fucking work right?," I would think when the pain still persists after a few days. But if I were physically disabled, this sort of mentality would be an unhealthy one that gets me to hate my body. No, it is not normal for someone to have such a seemingly crippling inability to be productive. But neither has being convinced that I am obviously capable of more gotten me to actually do more. I may be capable of more *one day*, but that day is not today. Letting go of the past and accepting where you are now is [one of the first steps](https://www.helpguide.org/wellness/health-conditions/living-well-with-a-disability) to living well with a disability, and while this isn't a "disability" in the usual sense, this is still a limitation that I must take into account for so long as it is present in my life.

On a more meta level, even this accompanying blog has mattered by spurring me to collect my thoughts in a much more organized manner than before. I've jotted down notes and thoughts over the years, but it wasn't like I had an important manifesto I needed to tell people about. Having an *existing* blog, on the other hand, means that thoughts don't have to be important to be serialized in essay form. Between the [inaugural blog post](/blog/v0.1.0/) and this current blog post, I have been able to document concrete examples of my coding and debugging thought processes. And from the way I procrastinated on writing the current blog post, I see that walking along this current journey of mine will be meaningful not just for improving my coding productivity, but for improving my productivity on any project I apply myself to in the future.

Finally, I do think this project is helping to rekindle the joy I used to find in coding. When I was a teenager, coding used to be play. Somewhere along the line, I forgot how to play and only knew how to write code that matters, whether for the paycheck or for personal goals. As I said [before](/blog/v0.1.0/), I used to do "things just because they were *fun*, not because they were going to matter one day." I remember when I was a teen, a new programming language or library would be an exciting new thing to try out. Somehow, nowadays I have acquired more of a sense of anxiety around such things: "Oh boy, am I doing this right? Ok, phew, I got it to work a little bit; let's commit before anything bad happens."
